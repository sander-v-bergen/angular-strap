{"version":3,"sources":["angular-strap.js","typeahead/typeahead.js","helpers/compiler.js","dropdown/dropdown.js","timepicker/timepicker.js","tooltip/tooltip.js","tab/tab.js","select/select.js","collapse/collapse.js","scrollspy/scrollspy.js","popover/popover.js","navbar/navbar.js","modal/modal.js","helpers/raf.js","helpers/parse-options.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","datepicker/datepicker.js","button/button.js","aside/aside.js","alert/alert.js","affix/affix.js","module.js"],"names":["placement","document","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","bsCompilerService","$inject","$http","get","angular","module","defaults","this","animation","data","compile","controller","console","controllerAs","resolve","copy","locals","bindToController","forEach","value","isString","$injector","key","invoke","transformTemplate","identity","extend","$template","when","$q","contentEl","findElement","outerHTML","contentTemplate","all","templateEl","removeAttr","html","templates","replace","next","remove","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","trigger","provider","container","keyboard","delay","minLength","filter","limit","autoSelect","comparator","trimValue","$get","bodyEl","$typeahead","$scope","$matches","config","$resetMatches","$$postDigest","activate","$activeIndex","select","index","$select","evt","matches","$isVisible","safeDigest","update","$$rAF","$render","$emit","prefixEvent","parentScope","length","l","$viewValue","i","preventDefault","stopPropagation","keyCode","$digest","show","$timeout","$element","$onMouseDown","hide","on","$onKeyDown","TypeaheadFactory","array","isFunction","$$phase","$window","body","$filter","expression","directive","results","restrict","require","falseValueRegExp","attr","bsOptions","test","parsedOptions","$parseOptions","typeahead","watchOptions","watchedOptions","$watchCollection","values","$match","$watch","ngModel","newValue","oldValue","$modelValue","valuesFn","selectMode","isVisible","slice","$formatters","displayValue","push","modelValue","selected","val","destroy","isDefined","label","toString","$on","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","maxTime","Infinity","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","isNative","$timepicker","$tooltip","timepickerFactory","formatDate","format","viewDate","hour","startDate","getHours","meridian","coeff","selRange","end","start","setSelectionRange","isUndefined","collapse","selectionStart","moveStart","selectionEnd","moveEnd","focusElement","focus","_init","init","floorMinutes","time","floor","lang","selectedIndex","date","defaultDate","second","getSeconds","millisecond","getMilliseconds","$dateValue","hoursFormat","$dateFormatter","$iconUp","$iconDown","$moveIndex","$switchMeridian","switchMeridian","isDate","isNaN","getMinutes","getTime","$build","minute","$setViewValue","keep","Date","setHours","setMinutes","setSeconds","hours","midIndex","$isSelected","disabled","minutes","seconds","minutesFormat","rows","showSeconds","secondsFormat","$isDisabled","showAM","timeSeparator","$date","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","parseInt","targetDate","target","nodeName","targetEl","triggerHandler","isTouch","sepLength","lateralMove","count","minutesLength","selectRange","hoursLength","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","prop","_destroy","off","_show","_hide","blur","$options","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","setFullYear","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","bsShow","timepicker","dateParser","$dateParser","$observe","validateAgainstMinMaxTime","getTimeForAttribute","parse","timezoneOffsetAdjust","NaN","title","type","autoClose","bsEnabled","viewport","selector","padding","String","htmlReplaceRegExp","$body","split","enterAnimateCallback","leaveAnimateCallback","_tipToHide","leave","$isShown","tipElement","triggers","toggle","unbindTriggerEvents","enter","bindKeyboardEvents","$onKeyUp","$onFocusElementMouseDown","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","rect","width","elRect","height","p","top","left","dimensions","offset","el","scroll","isBody","documentElement","getCalculatedOffset","position","actualWidth","actualHeight","outerDims","clientWidth","innerHeight","tip","marginTop","using","props","css","right","marginLeft","setOffset","delta","getViewportAdjustedDelta","isVertical","replaceArrow","arrowDelta","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","clearTimeout","timeout","tipScope","$destroy","$promise","$bsCompiler","$new","$rootScope","toLowerCase","$id","map","parseFloat","$sce","trustAsHtml","$setEnabled","id","$hide","setEnabled","isEnabled","compileData","promise","tipContainer","bindTriggerEvents","isElement","destroyTipElement","hoverState","parent","after","lastChild","display","visibility","clonedElement","version","minor","addClass","$animate","customClass","$applyPlacement","_blur","elementPosition","autoPlace","autoToken","viewportPosition","originalPlacement","indexOf","tipHeight","removeClass","tipPosition","applyPlacement","tipWidth","$location","transclusion","dataTarget","hasOwnProperty","tooltip","bsTooltip","match","setViewport","self","navClass","activeClass","$activeClass","$panes","$activePaneChangeListeners","$push","pane","$active","$attrs","$navClass","$remove","active","activeIndex","splice","$setActive","name","fn","$pane","$tab","transclude","postLink","ngModelCtrl","bsTabsCtrl","attrs","bsActivePane","parsedBsActivePane","assign","$parse","render","$isActive","prefixClass","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$activate","$selectNone","$updateActiveIndex","b","a","$apply","$getIndex","$selectScrollFix","$isIE","stopImmediatePropagation","ua","activeElement","tagName","e","dataMultiple","inputEl","addEventListener","isArray","join","$isEmpty","startCollapsed","allowMultiple","activeIndexes","$targets","activeItems","activateItem","$collapse","$viewChangeListeners","$registerToggle","$toggles","$unregisterToggle","$unregisterTarget","deactivateItem","fixActiveItemIndexes","disallowToggle","isActive","$activeIndexes","bsCollapseCtrl","controllers","bsCollapseToggle","$registerTarget","action","spies","debounce","$document","windowEl","throttle","ScrollSpyFactory","scrollEl","isWindowSpy","scrollId","$$count","$scrollspy","unbindViewContentLoaded","unbindIncludeContentLoaded","trackedElements","$trackedElements","sortedElements","activeTarget","debouncedCheckPosition","viewportHeight","throttledCheckPosition","debouncedCheckOffsets","scrollTop","checkPositionWithEventLoop","checkOffsets","checkPosition","docEl","$activateElement","offsetTop","setTimeout","source","$getTrackedElement","targetElement","querySelector","trackedElement","trackElement","toDelete","untrackElement","scrollspy","childEl","querySelectorAll","child","content","$popover","PopoverFactory","requestAnimationFrame","popover","bsPopover","routeAttr","$navbar","liElements","li","liElement","pattern","path","RegExp","regexp","backdrop","bodyElement","ModalFactory","$modal","modalElement","unbindBackdropEvents","hideOnBackdropClick","backdropElement","preventEventDefault","destroyModalElement","modalScope","$show","bottom","z-index","defaultPrevented","backdropAnimation","bindBackdropEvents","which","$root","query","bsModal","modal","cancelAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","raf","timer","$values","displayFn","valueName","valueFn","ParseOptionsFactory","groupByFn","keyName","jqLite","currentStyle","window","getComputedStyle","extra","boxRect","getBoundingClientRect","style","offsetHeight","docElement","ownerDocument","curPosition","curLeft","curCSSTop","pageYOffset","clientTop","pageXOffset","scrollLeft","clientLeft","curCSSLeft","calculatePosition","curTop","curOffset","curElem","call","offsetParentRect","offsetParentElement","offsetParent","offsetWidth","outer","func","immediate","factory","context","args","cancel","callNow","leading","trailing","wait","year","$localeProvider","milliseconds","ParseDate","prototype","isNumeric","n","isFinite","indexOfCaseInsensitive","len","str","strict","DateParserFactory","day","month","getFullYear","getMonth","proto","noop","toDate","regExpMap","sss","$locale","dateFilter","mm","keys","setFnMap","clonedFormat","search","v","sortedMap","regExpForFormat","re","text","Object","escapeReservedSymbols","regex","m","HH","H","hh","h","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","s","setDate","setMonth","setMap","setMapForFormat","$format","baseDate","formatRegex","formatSetMap","exec","fromDate","getDate","today","getDateForAttribute","substr","daylightSavingAdjust","undo","getDefaultLocale","getDatetimeFormat","weekdaysShort","splitTimeFormat","service","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","parentEl","hasClass","bsDropdown","dropdown","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","iconLeft","iconRight","DatepickerFactory","$datepicker","pickerViews","views","$iconLeft","$iconRight","$picker","$views","$mode","datepickerViews","$selectPane","$toggleMode","setMode","updateDisabledDates","disabledDateRanges","dateRanges","mode","pristine","$updateSelected","built","$setDisabledEl","isDisabled","steps","getUTCFullYear","getUTCMonth","UTC","getUTCDate","shiftKey","altKey","updateSelected","onKeyDown","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","daySplit","arr","mod","arrays","size","weekDaysMin","weekDaysLabelsHtml","picker","weekDaysLabels","concat","firstDayOfMonth","firstDate","getDay","firstDateOffset","build","days","isToday","toDateString","muted","showLabels","labels","isSelected","firstMonth","months","lastDate","actualMonth","firstYear","years","actualYear","setYear","$button","constantValueRegExp","isInput","trueValue","falseValue","hasExoticValues","equals","checked","bind","toggleEvent","toggleClass","AsideFactory","$aside","bsAside","aside","duration","dismissable","AlertFactory","$alert","bsAlert","alert","AffixFactory","$affix","inlineStyles","reset","setWidth","initialAffixTop","getRequiredAffixClass","unpin","getScrollTop","scrollHeight","getScrollHeight","initialOffsetTop","offsetBottom","affixed","$parseOffsets","affix","elementHeight","offsetUnpin","$onResize","$debouncedOnResize","initialPosition","affixTarget","option"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\n'use strict';\n\n// Source: typeahead/typeahead.js\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function() {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length,\n            i = l;\n          if (!l) return;\n          for (i = l; i--;) {\n            if (scope.$matches[i].value === value) break;\n          }\n          if (i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function() {\n            $typeahead.$element && $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if (options.keyboard) {\n              element && element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element && $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            element && element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function($filter) {\n    return function(array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function(results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      } else {\n        return $filter('filter')(array, expression, comparator);\n      }\n    };\n  })\n\n  .directive('bsTypeahead', function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function(key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue'], function(key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function(newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function(values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function(values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              var isVisible = typeahead.$isVisible();\n              isVisible && typeahead.update(values);\n              // Do not re-queue an update if a correct value has been selected\n              if (values.length === 1 && values[0].value === newValue) return;\n              !isVisible && typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (modelValue && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function() {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          element.val(options.trimValue === false ? value : value.trim());\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: timepicker/timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      //uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          secondsFormat = $dateFormatter.secondsFormat(format),\n          showSeconds = $dateFormatter.showSeconds(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function() {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [],\n            hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [],\n            minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [],\n            second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function(value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(),\n            hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(),\n            minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds(),\n            secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          if((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element && $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              element && element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if (!$timepicker.$isShown) return;\n          $timepicker.$element && $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            element && element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function(key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function(key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if (!timepicker || !angular.isDefined(newValue)) return;\n          if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tooltip/tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData, tipElement, tipContainer, tipScope;\n        promise.then(function(data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > viewportPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < viewportPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if(angular.isDefined(dataTarget)) {\n          if(falseValueRegExp.test(dataTarget))\n            options.target = false;\n          else\n            options.target = dataTarget;\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: tab/tab.js\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function(pane) {\n        if(angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function(pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if(angular.isString(active)) {\n          activeIndex = self.$panes.map(function(pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        }\n        else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if(activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function(value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n    };\n\n    this.$get = function() {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function(element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function(newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if(bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function(newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function() {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: select/select.js\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function($window, $document, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        }\n        else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function(index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function(matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function(index) {\n          if(options.multiple) {\n            $select.$isActive(index) ? scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1) : scope.$activeIndex.push(index);\n            if(options.sort) scope.$activeIndex.sort(function(a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function(index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function() {\n            $select.activate(index);\n            if(options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function(index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function() {\n          if(controller.$modelValue && scope.$matches.length) {\n            if(options.multiple && angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function(value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            }\n          } else if(scope.$activeIndex >= scope.$matches.length) {\n            scope.$activeIndex = options.multiple ? [] : 0;\n          } else if(!controller.$modelValue && !options.multiple) {\n            scope.$activeIndex = -1;\n          }\n        };\n\n        $select.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function(index) {\n          if(options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          } else {\n            return scope.$activeIndex === index;\n          }\n        };\n\n        $select.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $select.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function(evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if(!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if(evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function() {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function(e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function() {\n          _show();\n          if(options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function() {\n          if(!options.multiple && !controller.$modelValue) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if(angular.isDefined(dataMultiple)) {\n          if(falseValueRegExp.test(dataMultiple))\n            options.multiple = false;\n          else\n            options.multiple = dataMultiple;\n        }\n\n        // Add support for select markup\n        if(element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watchCollection(watchedOptions, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            select.update(values);\n            controller.$render();\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected, index;\n          if(options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function(value) {\n              index = select.$getIndex(value);\n              return angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if(selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if(options.multiple){\n          controller.$isEmpty = function(value){\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: collapse/collapse.js\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function(key) {\n        if(angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function(element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function(element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function(element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function(element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function(value) {\n        if(angular.isArray(value)) {\n          self.$targets.$active = value;\n        }\n        else if(!self.$options.disallowToggle) {\n          // toogle element active status\n          isActive(value) ? deactivateItem(value) : activateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function() {\n        return self.$options.allowMultiple ? self.$targets.$active :\n          self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for(var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function() {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function($window, $animate, $collapse) {\n\n    var defaults = $collapse.defaults;\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            }\n            else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              }\n              else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function() {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function() {\n          var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n          bsCollapseCtrl.$setActive(index * 1);\n          scope.$apply();\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if(bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          }\n          else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n\n// Source: scrollspy/scrollspy.js\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function() {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if(!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if(spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded, unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        var viewportHeight;\n        var scrollTop;\n\n        $scrollspy.init = function() {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if(scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function() {\n\n          // Check internal ref counter\n          this.$$count--;\n          if(this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function() {\n\n          // Not ready yet\n          if(!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if(scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if(angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if(activeTarget === sortedElements[i].target) continue;\n            if(scrollTop < sortedElements[i].offsetTop) continue;\n            if(sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function() {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function(element) {\n          if(activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if(activeElement) {\n              activeElement.source.removeClass('active');\n              if(nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if(nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function(target) {\n          return trackedElements.filter(function(obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function() {\n\n          angular.forEach(trackedElements, function(trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if(options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function(el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function(a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function(target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function(target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if(trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements = trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function(i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function() {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n\n// Source: popover/popover.js\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if(options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if(angular.isDefined(dataTarget)) {\n          if(falseValueRegExp.test(dataTarget))\n            options.target = false;\n          else\n            options.target = dataTarget;\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && requestAnimationFrame(function() {\n              popover && popover.$applyPlacement();\n            });\n          });\n        });\n\n        // Support scope as an object\n        attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n          angular.isDefined(oldValue) && requestAnimationFrame(function() {\n            popover && popover.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n          newValue === true ? popover.show() : popover.hide();\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          popover.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: navbar/navbar.js\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function() {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function() {\n\n          return $location.path();\n\n        }, function(newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function(li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if(options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if(regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: modal/modal.js\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var trim = String.prototype.trim;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if(!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function(key) {\n          if(options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData, modalElement, modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position:'fixed', top:'0px', left:'0px', bottom:'0px', right:'0px', 'z-index': 1038});\n        promise.then(function(data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function() {\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function() {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if(backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function() {\n          if($modal.$isShown) return;\n\n          var parent, after;\n          if(angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if(modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function(clonedElement, scope) {});\n\n          if(scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: animation\n          if(options.animation) {\n            if(options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if(options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function() {\n          if(!$modal.$isShown) return;\n\n          if(scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if(options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function() {\n\n          $modal.$isShown ? $modal.hide() : $modal.show();\n\n        };\n\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function(evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents() {\n          if(options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents() {\n          if(options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick(evt) {\n          if(evt.target !== evt.currentTarget) return;\n          options.backdrop === 'static' ? $modal.focus() : $modal.hide();\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement() {\n          if($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if(modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if(modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsModal && scope.$watch(attr.bsModal, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: helpers/raf.js\n(angular.version.minor < 3 && angular.version.dot < 14) && angular.module('ng')\n\n.factory('$$rAF', function($window, $timeout) {\n\n  var requestAnimationFrame = $window.requestAnimationFrame ||\n                              $window.webkitRequestAnimationFrame ||\n                              $window.mozRequestAnimationFrame;\n\n  var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                             $window.webkitCancelAnimationFrame ||\n                             $window.mozCancelAnimationFrame ||\n                             $window.webkitCancelRequestAnimationFrame;\n\n  var rafSupported = !!requestAnimationFrame;\n  var raf = rafSupported ?\n    function(fn) {\n      var id = requestAnimationFrame(fn);\n      return function() {\n        cancelAnimationFrame(id);\n      };\n    } :\n    function(fn) {\n      var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n      return function() {\n        $timeout.cancel(timer);\n      };\n    };\n\n  raf.supported = rafSupported;\n\n  return raf;\n\n});\n\n// .factory('$$animateReflow', function($$rAF, $document) {\n\n//   var bodyEl = $document[0].body;\n\n//   return function(fn) {\n//     //the returned function acts as the cancellation function\n//     return $$rAF(function() {\n//       //the line below will force the browser to perform a repaint\n//       //so that all the animated elements within the animation frame\n//       //will be properly updated and drawn on screen. This is\n//       //required to perform multi-class CSS based animations with\n//       //Firefox. DO NOT REMOVE THIS LINE.\n//       var a = bodyEl.offsetWidth + 1;\n//       fn();\n//     });\n//   };\n\n// });\n\n// Source: helpers/parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function() {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match, displayFn, valueName, keyName, groupByFn, valueFn, valuesFn;\n\n        $parseOptions.init = function() {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]),\n          valueName = match[4] || match[6],\n          keyName = match[5],\n          groupByFn = $parse(match[3] || ''),\n          valueFn = $parse(match[2] ? match[1] : valueName),\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function(scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function(values) {\n            if(!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function(modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function(match, index) {\n            var locals = {}, label, value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n\n// Source: helpers/dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n  \n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = fn.css(element, 'position'),\n          curElem = angular.element(element),\n          props = {};\n      \n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n      \n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && \n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n      \n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      \n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n      \n      if (options.top !== null ) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if ( options.left !== null ) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n\n// Source: helpers/debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function($timeout) {\n  return function(func, wait, immediate) {\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments,\n        callNow = immediate && !timeout;\n      if(timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if(!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if(callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function($timeout) {\n  return function(func, wait, options) {\n    var timeout = null;\n    options || (options = {});\n    return function() {\n      var context = this,\n        args = arguments;\n      if(!timeout) {\n        if(options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if(options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n// Source: helpers/date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function(value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format, timezone) {\n        // check for date format special names\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function(date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n\n// Source: helpers/date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function() {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function(format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function(lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function(date, format, lang, timezone){\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n\n// Source: helpers/compiler.js\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n  /* jshint validthis: true */\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function(options) {\n\n    if(options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function(value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      resolve.$template = $q.when(template);\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function(templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]).removeAttr('ng-bind').html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if(!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function(locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement(query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate(template) {\n    if(fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function(res) {\n        return res.data;\n      }));\n  }\n\n}\n\n// Source: dropdown/dropdown.js\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var scope = $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function(evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if(!items.length) return;\n          var index;\n          angular.forEach(items, function(el, i) {\n            if(matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if(evt.keyCode === 38 && index > 0) index--;\n          else if(evt.keyCode === 40 && index < items.length - 1) index++;\n          else if(angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            options.keyboard && $dropdown.$element && $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          parentEl.hasClass('dropdown') && parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function() {\n          if(!$dropdown.$isShown) return;\n          options.keyboard && $dropdown.$element && $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          parentEl.hasClass('dropdown') && parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function() {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if(evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Support scope as an object\n        attr.bsDropdown && scope.$watch(attr.bsDropdown, function(newValue, oldValue) {\n          scope.content = newValue;\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!dropdown || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n          newValue === true ? dropdown.show() : dropdown.hide();\n        });\n\n        // Initialize dropdown\n        var dropdown = $dropdown(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (dropdown) dropdown.destroy();\n          options = null;\n          dropdown = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: datepicker/datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      //uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if(options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function(date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function(value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function() {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function(date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function(dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function(date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if(!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if(!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if(options.autoclose && !keep) {\n              $timeout(function() { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function(mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function(pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if(pristine === true && $picker.built) return;\n          if(pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function() {\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function(date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function(el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function(value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if(evt.keyCode === 13) {\n            if(!scope.$mode) {\n              return $datepicker.hide(true);\n            } else {\n              return scope.$apply(function() { $datepicker.setMode(scope.$mode - 1); });\n            }\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function() {\n          if((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // if $datepicker is no longer showing, don't setup events\n            if(!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function(blur) {\n          if(!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    var defaults = $datepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!datepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          newValue === true ? datepicker.show() : datepicker.hide();\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if(isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            // console.warn('attr.$observe(%s)=%o', key, newValue);\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            // Build only if dirty\n            !isNaN(datepicker.$options[key]) && datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxDate(parsedDate);\n          }\n\n          if(options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.dateType === 'number') {\n            return date.getTime();\n          } else if(options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.dateType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if(options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function() {\n\n    var defaults = this.defaults = {\n      dayFormat: 'dd',\n      daySplit: 7\n    };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while(arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function($dateFormatter, $dateParser, $sce) {\n\n      return function(picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n            format: options.dayFormat,\n            split: 7,\n            steps: { month: 1 },\n            update: function(date, force) {\n              if(!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n                viewDate.date = picker.$date.getDate();\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1), firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n              var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5), firstDateOffset = firstDate.getTimezoneOffset();\n              var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n              if(firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n              var days = [], day;\n              for(var i = 0; i < 42; i++) { // < 7 * 6\n                day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n                days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n              }\n              scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n              scope.showLabels = true;\n              scope.labels = weekDaysLabelsHtml;\n              scope.rows = split(days, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n            },\n            isDisabled: function(date) {\n              var time = date.getTime();\n\n              // Disabled because of min/max date.\n              if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n              if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n              if (options.disabledDateRanges) {\n                for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                  if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualTime = picker.$date.getTime();\n              var newDate;\n\n              if(evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if(evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if(evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if(evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'month',\n            format: options.monthFormat,\n            split: 4,\n            steps: { year: 1 },\n            update: function(date, force) {\n              if(!this.built || date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstMonth = new Date(viewDate.year, 0, 1);\n              var months = [], month;\n              for (var i = 0; i < 12; i++) {\n                month = new Date(viewDate.year, i, 1);\n                months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n              }\n              scope.title = formatDate(month, options.yearTitleFormat);\n              scope.showLabels = false;\n              scope.rows = split(months, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualMonth = picker.$date.getMonth();\n              var newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if(evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if(evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if(evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'year',\n            format: options.yearFormat,\n            split: 4,\n            steps: { year: 12 },\n            update: function(date, force) {\n              if(!this.built || force || parseInt(date.getFullYear()/20, 10) !== parseInt(viewDate.year/20, 10)) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n              var years = [], year;\n              for (var i = 0; i < 12; i++) {\n                year = new Date(firstYear + i, 0, 1);\n                years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n              }\n              scope.title = years[0].label + '-' + years[years.length - 1].label;\n              scope.showLabels = false;\n              scope.rows = split(years, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualYear = picker.$date.getFullYear(),\n                  newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if(evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if(evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if(evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n\n// Source: button/button.js\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function() {\n\n    var defaults = this.defaults = {\n      activeClass:'active',\n      toggleEvent:'click'\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if(constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if(constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if(hasExoticValues) {\n          controller.$parsers.push(function(viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function(modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n             return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function(newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if(!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if(!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function(child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function(v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n\n// Source: aside/aside.js\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function($window, $sce, $aside) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAside && scope.$watch(attr.bsAside, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: alert/alert.js\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if(options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if(options.duration) {\n          $alert.show = function() {\n            show();\n            $timeout(function() {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function($window, $sce, $alert) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAlert && scope.$watch(attr.bsAlert, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: affix/affix.js\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n\n})(window, document);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      templateUrl: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'bsAsyncFilter',\n      limit: 6,\n      autoSelect: false,\n      comparator: '',\n      trimValue: true\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $$rAF, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function() {\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if (scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0 : -1;\n          }\n\n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          safeDigest(scope);\n          $$rAF($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          if (index === -1) return;\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if (parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if (!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length,\n            i = l;\n          if (!l) return;\n          for (i = l; i--;) {\n            if (scope.$matches[i].value === value) break;\n          }\n          if (i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if (!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden or no option is selected\n          if ($typeahead.$isVisible() && !(evt.keyCode === 13 && scope.$activeIndex === -1)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if (evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed immediately.\n          $timeout(function() {\n            $typeahead.$element && $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if (options.keyboard) {\n              element && element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element && $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if (options.keyboard) {\n            element && element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if (!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .filter('bsAsyncFilter', function($filter) {\n    return function(array, expression, comparator) {\n      if (array && angular.isFunction(array.then)) {\n        return array.then(function(results) {\n          return $filter('filter')(results, expression, comparator);\n        });\n      } else {\n        return $filter('filter')(array, expression, comparator);\n      }\n    };\n  })\n\n  .directive('bsTypeahead', function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id', 'prefixEvent', 'prefixClass'], function(key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'trimValue'], function(key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // Disable browser autocompletion\n        if (!element.attr('autocomplete')) element.attr('autocomplete', 'off');\n\n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if (filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if (limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if (options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watchCollection(watchedOptions, function(newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function(values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          });\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n            .then(function(values) {\n              // Prevent input with no future prospect if selectMode is truthy\n              // @TODO test selectMode\n              if (options.selectMode && !values.length && newValue.length > 0) {\n                controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n                return;\n              }\n              if (values.length > limit) values = values.slice(0, limit);\n              var isVisible = typeahead.$isVisible();\n              isVisible && typeahead.update(values);\n              // Do not re-queue an update if a correct value has been selected\n              if (values.length === 1 && values[0].value === newValue) return;\n              !isVisible && typeahead.update(values);\n              // Queue a new rendering that will leverage collection loading\n              controller.$render();\n            });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n\n          // If we can determine the displayValue, use that\n          if (displayValue) {\n            return displayValue;\n          }\n\n          // If there's no display value, attempt to use the modelValue.\n          // If the model is an object not much we can do\n          if (modelValue && typeof modelValue !== 'object') {\n            return modelValue;\n          }\n          return '';\n        });\n\n        // Model rendering in view\n        controller.$render = function() {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if (controller.$isEmpty(controller.$viewValue)) {\n            return element.val('');\n          }\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          var value = selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '') : '';\n          element.val(options.trimValue === false ? value : value.trim());\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n  /* jshint validthis: true */\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function(options) {\n\n    if(options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function(value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      resolve.$template = $q.when(template);\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function(templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]).removeAttr('ng-bind').html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if(!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function(locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement(query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate(template) {\n    if(fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function(res) {\n        return res.data;\n      }));\n  }\n\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var scope = $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function(evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if(!items.length) return;\n          var index;\n          angular.forEach(items, function(el, i) {\n            if(matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if(evt.keyCode === 38 && index > 0) index--;\n          else if(evt.keyCode === 40 && index < items.length - 1) index++;\n          else if(angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            options.keyboard && $dropdown.$element && $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          parentEl.hasClass('dropdown') && parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function() {\n          if(!$dropdown.$isShown) return;\n          options.keyboard && $dropdown.$element && $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          parentEl.hasClass('dropdown') && parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function() {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if(evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Support scope as an object\n        attr.bsDropdown && scope.$watch(attr.bsDropdown, function(newValue, oldValue) {\n          scope.content = newValue;\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!dropdown || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n          newValue === true ? dropdown.show() : dropdown.hide();\n        });\n\n        // Initialize dropdown\n        var dropdown = $dropdown(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (dropdown) dropdown.destroy();\n          options = null;\n          dropdown = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', ['mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      //uncommenting the following line will break backwards compatability\n      // prefixEvent: 'timepicker',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      templateUrl: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      secondStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if (!defaults.lang) {\n        defaults.lang = $dateFormatter.getDefaultLocale();\n      }\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time) {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {\n          hour: startDate.getHours(),\n          meridian: startDate.getHours() < 12,\n          minute: startDate.getMinutes(),\n          second: startDate.getSeconds(),\n          millisecond: startDate.getMilliseconds()\n        };\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          secondsFormat = $dateFormatter.secondsFormat(format),\n          showSeconds = $dateFormatter.showSeconds(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if (angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {\n              hour: date.getHours(),\n              minute: date.getMinutes(),\n              second: date.getSeconds(),\n              millisecond: date.getMilliseconds()\n            });\n            $timepicker.$build();\n          } else if (!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if (!angular.isDate(date)) date = new Date(date);\n          if (index === 0) controller.$dateValue.setHours(date.getHours());\n          else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function() {\n              $timepicker.hide(true);\n            });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [],\n            hour;\n          for (i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({\n              date: hour,\n              label: formatDate(hour, hoursFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n              disabled: $timepicker.$isDisabled(hour, 0)\n            });\n          }\n          var minutes = [],\n            minute;\n          for (i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({\n              date: minute,\n              label: formatDate(minute, minutesFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n              disabled: $timepicker.$isDisabled(minute, 1)\n            });\n          }\n          var seconds = [],\n            second;\n          for (i = 0; i < options.length; i++) {\n            second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n            seconds.push({\n              date: second,\n              label: formatDate(second, secondsFormat),\n              selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n              disabled: $timepicker.$isDisabled(second, 2)\n            });\n          }\n\n          var rows = [];\n          for (i = 0; i < options.length; i++) {\n            if (showSeconds) {\n              rows.push([hours[i], minutes[i], seconds[i]]);\n            } else {\n              rows.push([hours[i], minutes[i]]);\n            }\n          }\n          scope.rows = rows;\n          scope.showSeconds = showSeconds;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if (!$timepicker.$date) return false;\n          else if (index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if (index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          } else if (index === 2) {\n            return date.getSeconds() === $timepicker.$date.getSeconds();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if (index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n          } else if (index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n          } else if (index === 2) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function(value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value, index);\n          } else {\n            $timepicker.$moveIndex(value, index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date || startDate);\n          var hours = newDate.getHours();\n          var minutes = newDate.getMinutes();\n          var seconds = newDate.getSeconds();\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          } else if (index === 1) {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          } else if (index === 2) {\n            newDate.setSeconds(seconds - (parseInt(options.secondStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if (index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute, viewDate.second);\n            angular.extend(viewDate, {\n              hour: targetDate.getHours()\n            });\n          } else if (index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep), viewDate.second);\n            angular.extend(viewDate, {\n              minute: targetDate.getMinutes()\n            });\n          } else if (index === 2) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + (value * options.length * options.secondStep));\n            angular.extend(viewDate, {\n              second: targetDate.getSeconds()\n            });\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if (evt.keyCode === 13) {\n            $timepicker.hide(true);\n            return;\n          }\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(),\n            hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(),\n            minutesLength = formatDate(newDate, minutesFormat).length;\n          var seconds = newDate.getSeconds(),\n            secondsLength = formatDate(newDate, secondsFormat).length;\n          var sepLength = 1;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showSeconds * 1 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          var incr = 0;\n          if (evt.keyCode === 38) incr = -1;\n          if (evt.keyCode === 40) incr = +1;\n          var isSeconds = selectedIndex === 2 && showSeconds;\n          var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n          if (selectedIndex === 0) {\n            newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if (selectedIndex === 1) {\n            newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + sepLength, minutesLength];\n          } else if (isSeconds) {\n            newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n            // re-calculate seconds length because we have changes seconds value\n            secondsLength = formatDate(newDate, secondsFormat).length;\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength, secondsLength];\n          } else if (isMeridian) {\n            if (!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, length) {\n          var end = start + length;\n          if (element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if (element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if (angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if (isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if (isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if (isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          if((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element && $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if (options.keyboard) {\n              element && element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if (!$timepicker.$isShown) return;\n          $timepicker.$element && $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            element && element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {\n          scope: scope\n        };\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent'], function(key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative', 'roundDisplay'], function(key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if (!timepicker || !angular.isDefined(newValue)) return;\n          if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({\n          format: options.timeFormat,\n          lang: lang\n        });\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if (!isValid) {\n            return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if (!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if (!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // Return undefined, causes ngModelController to\n            // invalidate model value\n            return undefined;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if (options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if (options.timeType === 'number') {\n            return date.getTime();\n          } else if (options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if (options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if (angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if (angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if (options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if (options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData, tipElement, tipContainer, tipScope;\n        promise.then(function(data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > viewportPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < viewportPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if(angular.isDefined(dataTarget)) {\n          if(falseValueRegExp.test(dataTarget))\n            options.target = false;\n          else\n            options.target = dataTarget;\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // Please use $activePaneChangeListeners if you use `bsActivePane`\n      // Because we removed `ngModel` as default, we rename viewChangeListeners to\n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function(pane) {\n        if(angular.isUndefined(self.$panes.$active)) {\n          $scope.$setActive(pane.name || 0);\n        }\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function(pane) {\n        var index = self.$panes.indexOf(pane);\n        var active = self.$panes.$active;\n        var activeIndex;\n        if(angular.isString(active)) {\n          activeIndex = self.$panes.map(function(pane) {\n            return pane.name;\n          }).indexOf(active);\n        } else {\n          activeIndex = self.$panes.$active;\n        }\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to\n          // decrement the active pane index\n          activeIndex--;\n        }\n        else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        if(activeIndex >= 0 && activeIndex < self.$panes.length) {\n          self.$setActive(self.$panes[activeIndex].name || activeIndex);\n        } else {\n          self.$setActive();\n        }\n      };\n\n      self.$setActive = $scope.$setActive = function(value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$isActive = $scope.$isActive = function($pane, $index) {\n        return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n      };\n\n    };\n\n    this.$get = function() {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function(element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // 'ngModel' does interfere with form validation\n        // and status, use `bsActivePane` instead to avoid it\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function(newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Save tab name into scope\n        scope.name = attrs.name;\n\n        // Add animation class\n        if(bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function(newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function() {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function($window, $document, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        }\n        else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function(index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function(matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function(index) {\n          if(options.multiple) {\n            $select.$isActive(index) ? scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1) : scope.$activeIndex.push(index);\n            if(options.sort) scope.$activeIndex.sort(function(a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function(index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function() {\n            $select.activate(index);\n            if(options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function(index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function() {\n          if(controller.$modelValue && scope.$matches.length) {\n            if(options.multiple && angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function(value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            }\n          } else if(scope.$activeIndex >= scope.$matches.length) {\n            scope.$activeIndex = options.multiple ? [] : 0;\n          } else if(!controller.$modelValue && !options.multiple) {\n            scope.$activeIndex = -1;\n          }\n        };\n\n        $select.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function(index) {\n          if(options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          } else {\n            return scope.$activeIndex === index;\n          }\n        };\n\n        $select.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $select.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function(evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if(!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if(evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function() {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function(e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function() {\n          _show();\n          if(options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function() {\n          if(!options.multiple && !controller.$modelValue) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if(angular.isDefined(dataMultiple)) {\n          if(falseValueRegExp.test(dataMultiple))\n            options.multiple = false;\n          else\n            options.multiple = dataMultiple;\n        }\n\n        // Add support for select markup\n        if(element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watchCollection(watchedOptions, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            select.update(values);\n            controller.$render();\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected, index;\n          if(options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function(value) {\n              index = select.$getIndex(value);\n              return angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if(selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if(options.multiple){\n          controller.$isEmpty = function(value){\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // use string regex match boolean attr falsy values, leave truthy values be\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach(['disallowToggle', 'startCollapsed', 'allowMultiple'], function(key) {\n        if(angular.isDefined($attrs[key]) && falseValueRegExp.test($attrs[key])) {\n          self.$options[key] = false;\n        }\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function(element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function(element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function(element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function(element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function(value) {\n        if(angular.isArray(value)) {\n          self.$targets.$active = value;\n        }\n        else if(!self.$options.disallowToggle) {\n          // toogle element active status\n          isActive(value) ? deactivateItem(value) : activateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function() {\n        return self.$options.allowMultiple ? self.$targets.$active :\n          self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for(var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function() {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function($window, $animate, $collapse) {\n\n    var defaults = $collapse.defaults;\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            }\n            else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              }\n              else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function() {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function() {\n          var index = attrs.bsCollapseToggle && attrs.bsCollapseToggle !== 'bs-collapse-toggle' ? attrs.bsCollapseToggle : bsCollapseCtrl.$toggles.indexOf(element);\n          bsCollapseCtrl.$setActive(index * 1);\n          scope.$apply();\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if(bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          }\n          else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function() {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if(!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if(spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded, unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        var viewportHeight;\n        var scrollTop;\n\n        $scrollspy.init = function() {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if(scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function() {\n\n          // Check internal ref counter\n          this.$$count--;\n          if(this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function() {\n\n          // Not ready yet\n          if(!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if(scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if(angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if(activeTarget === sortedElements[i].target) continue;\n            if(scrollTop < sortedElements[i].offsetTop) continue;\n            if(sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function() {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function(element) {\n          if(activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if(activeElement) {\n              activeElement.source.removeClass('active');\n              if(nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if(nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function(target) {\n          return trackedElements.filter(function(obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function() {\n\n          angular.forEach(trackedElements, function(trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if(options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function(el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function(a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function(target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function(target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if(trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements = trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function(i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function() {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if(options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if(angular.isDefined(dataTarget)) {\n          if(falseValueRegExp.test(dataTarget))\n            options.target = false;\n          else\n            options.target = dataTarget;\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && requestAnimationFrame(function() {\n              popover && popover.$applyPlacement();\n            });\n          });\n        });\n\n        // Support scope as an object\n        attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n          angular.isDefined(oldValue) && requestAnimationFrame(function() {\n            popover && popover.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n          newValue === true ? popover.show() : popover.hide();\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          popover.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function() {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function() {\n\n          return $location.path();\n\n        }, function(newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function(li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if(options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if(regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var trim = String.prototype.trim;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        if(!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function(key) {\n          if(options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Fetch, compile then initialize modal\n        var compileData, modalElement, modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position:'fixed', top:'0px', left:'0px', bottom:'0px', right:'0px', 'z-index': 1038});\n        promise.then(function(data) {\n          compileData = data;\n          $modal.init();\n        });\n\n        $modal.init = function() {\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function() {\n\n          // Remove element\n          destroyModalElement();\n\n          // remove backdrop element\n          if(backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n        };\n\n        $modal.show = function() {\n          if($modal.$isShown) return;\n\n          var parent, after;\n          if(angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // destroy any existing modal elements\n          if(modalElement) destroyModalElement();\n\n          // create a new scope, so we can destroy it and all child scopes\n          // when destroying the modal element\n          modalScope = $modal.$scope.$new();\n          // Fetch a cloned element linked from template (noop callback is required)\n          modalElement = $modal.$element = compileData.link(modalScope, function(clonedElement, scope) {});\n\n          if(scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: animation\n          if(options.animation) {\n            if(options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if(options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function() {\n          if(!$modal.$isShown) return;\n\n          if(scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n\n          if(options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function() {\n\n          $modal.$isShown ? $modal.hide() : $modal.show();\n\n        };\n\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function(evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        function bindBackdropEvents() {\n          if(options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n\n        function unbindBackdropEvents() {\n          if(options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n\n        // Private helpers\n\n        function hideOnBackdropClick(evt) {\n          if(evt.target !== evt.currentTarget) return;\n          options.backdrop === 'static' ? $modal.focus() : $modal.hide();\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        function destroyModalElement() {\n          if($modal.$isShown && modalElement !== null) {\n            // un-bind events\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n\n          if(modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n\n          if(modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsModal && scope.$watch(attr.bsModal, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n(angular.version.minor < 3 && angular.version.dot < 14) && angular.module('ng')\n\n.factory('$$rAF', function($window, $timeout) {\n\n  var requestAnimationFrame = $window.requestAnimationFrame ||\n                              $window.webkitRequestAnimationFrame ||\n                              $window.mozRequestAnimationFrame;\n\n  var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                             $window.webkitCancelAnimationFrame ||\n                             $window.mozCancelAnimationFrame ||\n                             $window.webkitCancelRequestAnimationFrame;\n\n  var rafSupported = !!requestAnimationFrame;\n  var raf = rafSupported ?\n    function(fn) {\n      var id = requestAnimationFrame(fn);\n      return function() {\n        cancelAnimationFrame(id);\n      };\n    } :\n    function(fn) {\n      var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n      return function() {\n        $timeout.cancel(timer);\n      };\n    };\n\n  raf.supported = rafSupported;\n\n  return raf;\n\n});\n\n// .factory('$$animateReflow', function($$rAF, $document) {\n\n//   var bodyEl = $document[0].body;\n\n//   return function(fn) {\n//     //the returned function acts as the cancellation function\n//     return $$rAF(function() {\n//       //the line below will force the browser to perform a repaint\n//       //so that all the animated elements within the animation frame\n//       //will be properly updated and drawn on screen. This is\n//       //required to perform multi-class CSS based animations with\n//       //Firefox. DO NOT REMOVE THIS LINE.\n//       var a = bodyEl.offsetWidth + 1;\n//       fn();\n//     });\n//   };\n\n// });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function() {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match, displayFn, valueName, keyName, groupByFn, valueFn, valuesFn;\n\n        $parseOptions.init = function() {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]),\n          valueName = match[4] || match[6],\n          keyName = match[5],\n          groupByFn = $parse(match[3] || ''),\n          valueFn = $parse(match[2] ? match[1] : valueName),\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function(scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function(values) {\n            if(!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function(modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function(match, index) {\n            var locals = {}, label, value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n  \n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = fn.css(element, 'position'),\n          curElem = angular.element(element),\n          props = {};\n      \n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n      \n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && \n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n      \n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      \n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n      \n      if (options.top !== null ) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if ( options.left !== null ) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function($timeout) {\n  return function(func, wait, immediate) {\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments,\n        callNow = immediate && !timeout;\n      if(timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if(!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if(callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function($timeout) {\n  return function(func, wait, options) {\n    var timeout = null;\n    options || (options = {});\n    return function() {\n      var context = this,\n        args = arguments;\n      if(!timeout) {\n        if(options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if(options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function(value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format, timezone) {\n        // check for date format special names\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function(date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function() {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function(format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function(lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function(date, format, lang, timezone){\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      //uncommenting the following line will break backwards compatability\n      // prefixEvent: 'datepicker',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      templateUrl: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if(options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function(date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function(value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function() {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function(date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function(dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function(date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if(!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if(!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if(options.autoclose && !keep) {\n              $timeout(function() { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function(mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function(pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if(pristine === true && $picker.built) return;\n          if(pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function() {\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function(date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function(el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function(value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if(evt.keyCode === 13) {\n            if(!scope.$mode) {\n              return $datepicker.hide(true);\n            } else {\n              return scope.$apply(function() { $datepicker.setMode(scope.$mode - 1); });\n            }\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function() {\n          if((!isTouch && element.attr('readonly')) || element.attr('disabled')) return;\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // if $datepicker is no longer showing, don't setup events\n            if(!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function(blur) {\n          if(!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    var defaults = $datepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoclose', 'useNative'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!datepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          newValue === true ? datepicker.show() : datepicker.hide();\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if(isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            // console.warn('attr.$observe(%s)=%o', key, newValue);\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            // Build only if dirty\n            !isNaN(datepicker.$options[key]) && datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxDate(parsedDate);\n          }\n\n          if(options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.dateType === 'number') {\n            return date.getTime();\n          } else if(options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.dateType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if(options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function() {\n\n    var defaults = this.defaults = {\n      dayFormat: 'dd',\n      daySplit: 7\n    };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while(arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function($dateFormatter, $dateParser, $sce) {\n\n      return function(picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n            format: options.dayFormat,\n            split: 7,\n            steps: { month: 1 },\n            update: function(date, force) {\n              if(!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getDate() !== viewDate.date || date.getDate() === 1) {\n                // chaging picker current month will cause viewDate.date to be set to first day of the month,\n                // in $datepicker.$selectPane, so picker would not update selected day display if\n                // user picks first day of the new month.\n                // As a workaround, we are always forcing update when picked date is first day of month.\n                viewDate.date = picker.$date.getDate();\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1), firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n              var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5), firstDateOffset = firstDate.getTimezoneOffset();\n              var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n              if(firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n              var days = [], day;\n              for(var i = 0; i < 42; i++) { // < 7 * 6\n                day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n                days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n              }\n              scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n              scope.showLabels = true;\n              scope.labels = weekDaysLabelsHtml;\n              scope.rows = split(days, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n            },\n            isDisabled: function(date) {\n              var time = date.getTime();\n\n              // Disabled because of min/max date.\n              if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n              if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n              if (options.disabledDateRanges) {\n                for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                  if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualTime = picker.$date.getTime();\n              var newDate;\n\n              if(evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if(evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if(evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if(evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'month',\n            format: options.monthFormat,\n            split: 4,\n            steps: { year: 1 },\n            update: function(date, force) {\n              if(!this.built || date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstMonth = new Date(viewDate.year, 0, 1);\n              var months = [], month;\n              for (var i = 0; i < 12; i++) {\n                month = new Date(viewDate.year, i, 1);\n                months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n              }\n              scope.title = formatDate(month, options.yearTitleFormat);\n              scope.showLabels = false;\n              scope.rows = split(months, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualMonth = picker.$date.getMonth();\n              var newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if(evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if(evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if(evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'year',\n            format: options.yearFormat,\n            split: 4,\n            steps: { year: 12 },\n            update: function(date, force) {\n              if(!this.built || force || parseInt(date.getFullYear()/20, 10) !== parseInt(viewDate.year/20, 10)) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n              var years = [], year;\n              for (var i = 0; i < 12; i++) {\n                year = new Date(firstYear + i, 0, 1);\n                years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n              }\n              scope.title = years[0].label + '-' + years[years.length - 1].label;\n              scope.showLabels = false;\n              scope.rows = split(years, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualYear = picker.$date.getFullYear(),\n                  newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if(evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if(evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if(evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function() {\n\n    var defaults = this.defaults = {\n      activeClass:'active',\n      toggleEvent:'click'\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if(constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if(constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if(hasExoticValues) {\n          controller.$parsers.push(function(viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function(modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n             return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function(newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if(!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if(!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function(child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function(v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      templateUrl: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function($window, $sce, $aside) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['backdrop', 'keyboard', 'html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAside && scope.$watch(attr.bsAside, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if(options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if(options.duration) {\n          $alert.show = function() {\n            show();\n            $timeout(function() {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function($window, $sce, $alert) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAlert && scope.$watch(attr.bsAlert, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n","\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n"],"sourceRoot":"/source/"}